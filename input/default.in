# Output filename
output_filename = results

# Process settings
sroot        = 7e3            # center-of-mass energy
ih1          = 1              # hadron 1
ih2          = 1              # hadron 2
nproc        = 3              # process: 1) W+; 2)W-; 3)Z(/gamma*)
g_param      = 1.0            # non perturbative g parameter
order        = 2              # order: 0) LO(+LL) 1) NLO(+NLL), 2) NNLO(+NNLL)
fixedorder   = false          # resummation or fixed order switch

#PDF settings
LHAPDFset    = CT10nnlo       # PDF set from LHAPDF
LHAPDFmember = 0              # PDF member
PDFerrors    = false	      # calculate PDF errors

#QCD scale settings

#Functional form of QCD scales
#0: mu^2 = mV^2
#1: mu^2 = mll^2
#2: mu^2 = mll^2+pT^2
#3: mu^2 = mll^2+pT^2+mjj^2

#---> probably need just one of these options...
fmuren = 0     # Functional form of the renormalisation scale
fmufac = 0     # Functional form of the factorisation scale
fmures = 1     # Functional form of the resummation scale (forms 2 and 3 are equivalent to 1)

kmuren = 1.          # scale factor for the renormalisation scale
kmufac = 1.          # scale factor for the factorisation scale
kmures = 0.5         # scale factor for the resummation scale

#Additional resummation scales
C1 = 1.
C3 = 1.

#PDF matching scales
kmuc          = 1.        # scale factor for the charm matching scale
kmub          = 1.        # scale factor for the bottom matching scale
kmut          = 1.        # scale factor for the top matching scale


# EW parameters and scheme

# ewscheme choices:
#0: Input: alpha(mZ), zmass, xw;        derived:wmass, Gf
#1: Input: Gf, wmass, zmass;            derived: xw, alpha(mZ)    [Gmu scheme]
#2: Input: Gf, alpha(mZ), xw, Gf;       derived: wmass, zmass
#3: All masses and couplings determined by inputs
ewscheme = 1

Gf = 1.1663787e-5        # G-Fermi
zmass = 91.1876          # Mass of the Z boson
wmass = 80.385           # Mass of the W boson

xw = 0.23153                 # weak-mixing angle (not used in the Gmu scheme)
aemmz = 7.7585538055706e-03  # alpha_EM(MZ) (not used in the Gmu scheme)

#W and Z total widths used in the propagators are determined by the following inputs
zwidth = 2.4950          # Width of the Z boson
wwidth = 2.091           # Width of the W boson
zerowidth = false        # zero-width approximation (not really implemented)
runningwidth = false     # Use Z and W propagators including energy-dependent width effects

# CKM matrix
Vud = 0.97427
Vus = 0.2253
Vub = 0.00351
Vcd = 0.2252
Vcs = 0.97344
Vcb = 0.0412

# Z/gamma* coupling to quarks
Zuu = 1.0
Zdd = 1.0
Zss = 1.0
Zcc = 1.0
Zbb = 1.0

# include virtual photon in Z/gamma* production
useGamma = true


# Resummation parameters
resumcpp  = true  # use C++ code for resummation
ctcpp     = true  # use C++ code for the counter term
qtcutoff = 0.02   # resummation cutoff

# modlog = true: modified logarithms in the Sudakov L~ = log( (Q*b/b0)^2 + 1)
# modlog = false: canonical logarithms in the Sudakov L = log( (Q*b/b0)^2 )
modlog = true

# Prescription to avoid the Landau pole in the Bessel inverse transform
# 0: bstar prescription, which freezes b at bmax: b -> bstar = b/sqrt(1+b^2/bmax^2)
# 1: Integrate all the way up to the Landau singularity b_L = b0/Q * exp(1/(2*beta0*alphas))
# 2: Minimal prescription (complex plane)
# 3: Minimal prescription (real axis)
bprescription = 0

blim = -1         #blim for the bstar prescription, applies to bprescription = 0. A positive value set a fixed bmax=blim, a negative values sets bmax=b_L/(-blim), where b_L is the Landau singularity.

phibr = 4.        #set arg(z) as phib = pi/phibr  for the integration contour in the complex plane for bprescription = 2 (should be set phibr > 4. )
bcf = 0.5         #select the point bc = bcf * b_L, where the integration contour is bended in the complex plane, as a fraction of the Landau singularity b_L. Applies to bprescription = 2 or 3

# Strategy for the direct Mellin transform of PDFs at the factorization scale
# Set to 1 to use the dyres approximation of PDFs and integration contour in the complex plane for the Mellin inversion
# Set to 0 to use exact PDFs and straight line contour in the complex plane for the Mellin inversion
opts_approxpdf = 0
# number of intervals for integration of PDF moments (direct Mellin transform), relevant only for opts_approxpdf = 0
opts_pdfintervals = 100
pdfrule = 100     #Gaussian rule for the x-to-N Mellin transform

# Type of PDF evolution
#0: DYRES (backward evolution)
#1: Pegasus as DYRES (backward evolution)
#2: Mellin transform (forward evolution)
#3: Pegasus VFN (forward evolution)
#4: Pegasus VFN with alphas from DYRES (forward evolution)
evolmode = 0

# Split the Bessel inverse transform in 3 pieces corresponding to NF=3,4,5
# and compute a NF-dependent Sudakov form factor
vfnsudakov = false

#Settings for the Bessel integration
bintaccuracy = 1.0e-4  #accuracy

#Settings for the inverse Mellin integrations
mellininv = 0       #Strategy for the mellin inverstion (0 Gauss-Legendre, 1 Talbot)
mellinintervals = 1 #number of intervals
mellinrule = 64     #number of nodes

#options for the Mellin inversion with Gauss-Legendre integration
zmax = 27.   	    #upper limit of the contour in the imaginary axis
cpoint = 1.   	    #point of intersection of the contour with the real axis
phi = 0.5           #angle between the real axis and the linear contour in units of pi

mellincores = 1     #number of parallel threads for the mellin integration
mellin1d = false    #use 1d (y-integrated) or 2d (y-dependent) mellin inversion
xspace = false      #access PDFs in Bjorken-x space, without Mellin inversion (option available only in the LL case where the convolution is trivial)

#number of intervals and gaussian rule for the rapidity integrations in the 2dim resummed piece
yintervals = 1
yrule = 20

#number of intervals and gaussian rule for the qt integration in the 2dim counter term
qtintervals = 1
qtrule = 64

#number of intervals and gaussian rule for the alfa beta scaled-PDF integration in the counter term and born fixed order term
abintervals = 1
abrule = 64

#gaussian rule for the phi integration in the V+J 5d LO term when makecuts is false
vjphirule = 20

#settings for the z1, z2 integration in the V+J 3d NLO term
zrule = 64

#settings for the x integration in the V+J 3d delta term
xrule = 200

# resummation damping
dampk = 0.5
dampdelta = 0.5
dampmode = 1


# qt-subtraction cut-off. Both conditions are applied, at least one between qtcut and xqtcut must be > 0
xqtcut = 0.008  # cutoff on qt/m
qtcut = 0.      # cutoff on qt

# integration settings
rseed        = 123456         # random seed for MC integration

# type of integration for the resummed cross section
intDimRes = 4 # can be 1, 2 or 3 for quadrature, or 4 for vegas

# type of integration for the born configuration
intDimBorn = 2 # can be 2 for quadrature, 4 or 6 for vegas

# type of integration for counter term
intDimCT = 2 # can be 1, 2 or 3 for quadrature, or 6, or 8 for vegas

# type of integration for V+J finite order
intDimVJ = 3 # can be 3 for quadrature, 5 for quadrature with cuts, or 7 for vegas

# term switches
doBORN = true
doCT   = true
doVJ   = true

doVJREAL = true
doVJVIRT = true

# Cuba settings
cubaverbosity     = 0   # Cuba info messsages, from 0 to 3
cubacores         = 0   # parallelization ( 0 = turn off)
cubanbatch        = 1000  # the batch size for sampling in Cuba vegas integration
niterBORN         = 5   # only for 2d and 3d cuhre integration of resummed part
niterCT           = 5   # only for 2d and 3d cuhre integration of counter term
niterVJ           = 10       # only for 3d cuhre integration of V+J
vegasncallsBORN   = 1000     # only for res 4d vegas integration
vegasncallsCT     = 100000   # only for 6d and 8d vegas integration of the counter term
vegasncallsVJLO   = 10000000 # only for lo 7d vegas integration
vegasncallsVJREAL = 10000000 # only for real 10d vegas integration
vegasncallsVJVIRT = 1000000  # only for virt 8d vegas integration
vegascollect      = false    # collect points from all the vegas iterations (true) or only from the last iteration (false)

# cubature settings
pcubature = true
pcubaccuracy = 1e-3

# costh CS boundaries
costhmin = -1
costhmax = +1

# Lepton cuts
# Total cross section or with lepton cuts
makecuts = false

# charged leptons cuts
lptcut = 20
lycut = 2.5

# leptons and antileptons cuts
lepptcut = 0
lepycut = 1000
alpptcut = 0
alpycut = 1000

#absolute-rapidity-ordered leptons (central and forward)
lcptcut = 0
lcymin = 0
lcymax = 1000
lfptcut = 0
lfymin = 0
lfymax = 1000

# cuts on neutrino and transverse mass
etmisscut = 0
mtcut = 0

#costh CS
cthCSmin = -1
cthCSmax = +1

# integration types and settings for costh phi_lep phase space
cubaint   = false   # integration with Cuba Suave
trapezint = false  # trapezoidal rule for the phi_lep integration and semi-analytical for costh
quadint   = true  # quadrature rule for the phi_lep integration and semi-analytical for costh

suavepoints  = 1000000 # number of points for suave integration, newpoints is set to suavepoints/10;
nphitrape    = 1000    # number of steps for trapezoidal rule of phi_lep integration
phirule      = 4       # quadrature rule of phi_lep integration
phiintervals = 20      # number of segments for quadrature rule of phi_lep integration
ncstart      = 100     # starting sampling for the costh semi-analytical integration (common settings for the trapezoidal and quadrature rules)

# qt-recoil prescriptions
qtrec_naive = false
qtrec_cs    = true
qtrec_kt0   = false

# debug settings
timeprofile = false  # debug and time profile resummation integration
verbose     = false  # debug and time profile costh phi_lep integration
texttable   = true # dump result table to text file (including pdf variations)
unicode     = false # use unicode characters for the table formatting

# binning

# normalise cross sections by bin width
ptbinwidth = false
ybinwidth = false

# Force to loop over all bins even you have all Vegas integrands
force_binsampling = false

# Compute total (-1) or helicity cross sections (0-7)
helicity = -1

# pt, y, m bins
qt_bins = [ 0 2 4 6 8 10 12 14 16 18 22 26 30 34 38 42 46 50 54 60 70 80 100 150 200 300 800 ]
y_bins = [ -5. 0.  5. ]
m_bins = [ 50 66. 116.  1000. ]

# binning for user testing histogram
biganswer_bins = [ 41 42 43 ]

#   # z angular
#   qt_bins = [ 0 2.5 5.0 8.0 11.4 14.9 18.5 22.0 25.5 29.0 32.6 36.4 40.4 44.9 50.2 56.4 63.9 73.4 85.4 105.0 132.0 173.0 253.0 600.0 ]
#   y_bins = [ -5  5 ]
